<!DOCTYPE html>
<html>
<body>
<h2>ü§© ¬°Herencia protot√≠pica!</h2>
<script>
Herencia protot√≠pica

Al igual que otros tipos de datos, un hereda propiedades y m√©todos de un prototipo integrado de Object, lo que significa que el objeto resultante contiene tanto las propiedades que definiste como una propiedad prototipo que contiene los m√©todos heredados del prototipo:


let myObject = {
    'booleanValue' : true
};

myObject;
> Object { booleanValue: true }
    booleanValue: true
    [[prototype]]: Object { ‚Ä¶ }
            __defineGetter__: function __defineGetter__()
            __defineSetter__: function __defineSetter__()
            __lookupGetter__: function __lookupGetter__()
            __lookupSetter__: function __lookupSetter__()
            __proto__: ‚Ä¶
                constructor: function Object()
                hasOwnProperty: function hasOwnProperty()
                isPrototypeOf: function isPrototypeOf()
                propertyIsEnumerable: function propertyIsEnumerable()
                toLocaleString: function toLocaleString()
                toString: function toString()
                valueOf: function valueOf()
                <get __proto__()>: function __proto__()
                <set __proto__()>: function __proto__()
No est√° dise√±ado para que se acceda a las propiedades de prototipo de forma directa con una clave de propiedad. Como Como puedes ver en el ejemplo anterior, esto est√° impl√≠cito en el [[prototype]] o la notaci√≥n <prototype> que se usa en los navegadores consolas para desarrolladores y fuentes documentaci√≥n para la clave de propiedad del prototipo:


// Chrome:
let emptyObject = {};

emptyObject;
> {}
  [[prototype]]: Object

// Firefox:
let emptyObject = {};

emptyObject;
> Object {  }
  <prototype>: Object { ‚Ä¶ }
Si bien todos los navegadores comunes usan __proto__ como est√°ndar de facto, este no es estandarizada formalmente y debe evitarse en el c√≥digo de producci√≥n.


let emptyObject = {};

emptyObject.__proto__;
> Object { ‚Ä¶ }
    __defineGetter__: function __defineGetter__()
    __defineSetter__: function __defineSetter__()
    __lookupGetter__: function __lookupGetter__()
    __lookupSetter__: function __lookupSetter__()
    __proto__:
        constructor: function Object()
        hasOwnProperty: function hasOwnProperty()
        isPrototypeOf: function isPrototypeOf()
        propertyIsEnumerable: function propertyIsEnumerable()
        toLocaleString: function toLocaleString()
        toString: function toString()
        valueOf: function valueOf()
        <get __proto__()>: function __proto__()
        <set __proto__()>: function __proto__()
En su lugar, puedes acceder directamente al [[Prototype]] de un objeto y modificarlo con Object.getPrototypeOf() y Object.setPrototypeOf() integrados m√©todos:


let myObj = { "value" : 5 };
let protoParent = { "protoValue" : true };

myObj;
Object { value: 5 }
    value: 5
    <prototype>: Object { ‚Ä¶ }

Object.getPrototypeOf( myObj );
> Object { ‚Ä¶ }
    __defineGetter__: function __defineGetter__()
    __defineSetter__: function __defineSetter__()
    __lookupGetter__: function __lookupGetter__()
    __lookupSetter__: function __lookupSetter__()
    __proto__:
    constructor: function Object()
    hasOwnProperty: function hasOwnProperty()
    isPrototypeOf: function isPrototypeOf()
    propertyIsEnumerable: function propertyIsEnumerable()
    toLocaleString: function toLocaleString()
    toString: function toString()
    valueOf: function valueOf()
    <get __proto__()>: function __proto__()
    <set __proto__()>: function __proto__()

Object.setPrototypeOf( myObj, protoParent );
> Object { value: 5 }
    value: 5
    <prototype>: Object { protoValue: true }
Para diferenciar entre las propiedades heredadas y las definidas por el autor, el m√©todo estas √∫ltimas generalmente se denominan ‚Äúpropiedades propias‚Äù del objeto.

El m√©todo Object.hasOwn() integrado muestra true si la propiedad especificada. es una propiedad directa del objeto y false si la propiedad es heredada o no existe. Siempre que sea posible, usa Object.hasOwn(). en lugar del m√©todo hasOwnProperty() heredado, que no admite Object.create()


let myObject = {
    'myValue' : 100
};

Object.hasOwn( myObject, 'myValue' );
> true

myObject.__proto__; // The Object prototype inherited by `myObject` is present:
> Object { ‚Ä¶ }

Object.hasOwn( myObject, '__proto__' ); // The Object prototype inherited by `myObject` is not an "own property:"
> false
</script>
</body>
</html>