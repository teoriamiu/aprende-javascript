<!DOCTYPE html>
<html>
<body>
<h2>ðŸ˜˜ Â¡Funciones!</h2>
<script>
Funciones

Una funciÃ³n es un bloque de sentencias modular y reutilizable que se usa para realizar tareas relacionadas, como calcular y mostrar un valor basado en argumentos proporcionados a la funciÃ³n. Al igual que con todos los valores no primitivos, las funciones son objetos. Son objetos Ãºnicos en los que se pueden llamar ejecutar el cÃ³digo, pasar datos en forma de argumentos y devuelve un valor.

Las funciones se consideran "primera clase" objetos, lo que significa que, a pesar de su comportamiento Ãºnico, se pueden usar en todos los los mismos contextos que cualquier otro objeto JavaScript. Por ejemplo, una funciÃ³n puede ser asignado a una variable, pasado como argumento a otras funciones y devueltos por otras funciones.

function myFunction() {
   console.log( "This is my function." );
};
Una funciÃ³n definida como una propiedad de un objeto es generalmente se denomina "mÃ©todo". Al igual que con las variables declaradas con var, las declaraciones de funciÃ³n realizadas fuera de una funciÃ³n contenedora se agregan al objeto global como mÃ©todos.

Declaraciones de funciones
Una declaraciÃ³n de funciÃ³n (tambiÃ©n llamada â€œdeclaraciÃ³n de funciÃ³nâ€ o â€œdefiniciÃ³n de funciÃ³nâ€) Crea una funciÃ³n con nombre que puede invocarse en otro lugar del alcance que la contiene. Las declaraciones de funciÃ³n consisten en la palabra clave function seguida de un identificador, una lista de parÃ¡metros separados por comas encerrados entre parÃ©ntesis y un instrucciÃ³n de bloque llamada â€œcuerpo de la funciÃ³nâ€. A menudo encontrarÃ¡s declaraciones de funciones que no terminar con punto y coma; ya que una declaraciÃ³n de funciÃ³n es una instrucciÃ³n y punto y coma se puede inferir por medio de ASI.

function myFunction() {
   console.log( "This is my function." );
};

myFunction();
> "This is my function."
Como un obstÃ¡culo de las primeras decisiones de diseÃ±o de JavaScript, las declaraciones de funciones estÃ¡n sujetas a la misma elevaciÃ³n heredada como variables declaradas con var, lo que significa que una declaraciÃ³n de funciÃ³n se eleva a la parte superior de su alcance y puede llamarse antes de la declaraciÃ³n como resultado, ya sea que ese alcance estÃ© regido por el modo estricto o no:

"use strict";
{
    myFunction();
    function myFunction() {
        console.log( "This is my function." );
    };
}
> "This is my function."
Fuera del modo estricto, funciÃ³n las declaraciones usan el alcance heredado de JavaScript comportamiento, lo que significa que el alcance de una declaraciÃ³n de funciÃ³n se define con su alcance mÃ¡s cercano funciÃ³n:

function myFunction() {
    function myNestedFunction() {
        console.log( "This is my nested function." );
    }
    myNestedFunction();
};

myFunction();
> "This is my nested function."

myNestedFunction();
>Uncaught ReferenceError: myNestedFunction is not defined
En el modo estricto, las declaraciones de funciones el alcance se establece en su bloque de contenedor mÃ¡s cercano, como sucede con las variables declaradas mediante let o const:

"use strict";
{
    function myFunction() {
        console.log( "This is my function." );
    };
}

myFunction();
> Uncaught ReferenceError: myFunction is not defined
Llamada a funciÃ³n
Al igual que con las variables, el identificador que se usa cuando se declara una funciÃ³n actÃºa como un un nombre simbÃ³lico para un valor. Hacer referencia a una funciÃ³n solo con el identificador muestra solo el objeto de la funciÃ³n y no ejecuta la funciÃ³n que contiene:

function myFunction() {
   console.log( "This is my function." );
};

myFunction;
> myFunction() {
   console.log( "This is my function." );
}
Para ejecutar el cÃ³digo dentro del cuerpo de la funciÃ³n, llama (o invoca) la funciÃ³n. siguiendo el nombre de la funciÃ³n con un par de parÃ©ntesis coincidente:

function myFunction() {
    console.log( "My function has been executed." );
}

myFunction();
> "My function has been executed."
Los parÃ¡metros en la definiciÃ³n de la funciÃ³n actÃºan como variables de marcador de posiciÃ³n para valores que se pueden pasar al cuerpo de la funciÃ³n cuando se la llama. Los valores entre parÃ©ntesis cuando se llama a una funciÃ³n son â€œargumentosâ€ (aunque es posible que veas â€œargumentosâ€ que se usa para describir argumentos y parÃ¡metros en algunas documentaciÃ³n):

function myFunction( myParameter ) {
   console.log( `The value is: ${ myParameter }.` );
};

myFunction( "this string" );
> "The value is: this string."
Si se omite un argumento esperado, el parÃ¡metro resultante contiene un valor undefined, porque el parÃ¡metro se declara en el cuerpo de la funciÃ³n, pero no inicializado con un valor:

function myFunction( myParameter ) {
   console.log( `The value is: ${ myParameter }.` );
};

myFunction();
> "The value is: undefined."
Puedes establecer valores de parÃ¡metros predeterminados si los inicializas de la misma manera que lo harÃ­as inicializamos una variable: un operador de asignaciÃ³n (=) seguido de un valor. Si especificar un argumento para esa funciÃ³n, ese valor nuevo anula valor predeterminado:

function myFunction( myParameter = "omitted" ) {
   console.log( `The value is: ${ myParameter }.` );
};

myFunction( "this string" );
> "The value is: this string."

myFunction();
> "The value is: omitted."
El cuerpo de una no flecha tambiÃ©n tiene acceso a una entrada no indexada, Un objeto arguments similar a un array que contenga cualquier valor pasado como argumento, ya sea que la funciÃ³n definiciÃ³n especifica los parÃ¡metros:

function myFunction() {
   console.log( arguments );
};

myFunction( 3, true, "My string" );
> Arguments { 0: 3, 1: true, 2: "My string", â€¦ }
Funciones variadicas
El objeto arguments te permite crear funciones variables bÃ¡sicas, que pueden aceptar una cantidad variable de argumentos:

function myFunction() {
    let result = "";
    for (let i = 0; i < arguments.length; i++) {
        result += arguments[i] + " - ";
    }
    console.log( result );
};

myFunction( "My first string", "My second string", "my third string" );\
> "My first string - My second string - my third string - "
Sin embargo, este enfoque para las funciones variÃ¡dicas rara vez se utiliza en el JavaScript moderno. en el desarrollo de software. Es mÃ¡s comÃºn usar el framework mÃ¡s moderno y legible sintaxis del parÃ¡metro rest lo que crea un parÃ¡metro con nombre inicializado como un array que contiene argumentos aparte de los especificados explÃ­citamente:

function myFunction( mySeparator, ...myStrings ) {
  console.log( myStrings.join( mySeparator ) );
};

myFunction( " - ", "My first string", "My second string", "my third string" );
> "My first string - My second string - my third string"
A diferencia de la vinculaciÃ³n de parameter, la sintaxis del parÃ¡metro rest funciona como se espera con los parÃ¡metros de la funciÃ³n de flecha:

function myOuterFunction() {
    let myInnerArrowFunction = ( ...myParams ) => {
        console.log( myParams[ 0 ] );
    }
    myInnerArrowFunction( true );
};

myOuterFunction( false );
> true

let myArrowFunction = ( ...myParams ) => {
    console.log( myParams[ 0 ] );
};

myArrowFunction( true );
> true
</script>
</body>
</html>