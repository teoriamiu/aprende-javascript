<!DOCTYPE html>
<html>
<body>
<h2>üò£ ¬°Ap√©ndice!</h2>
<script>
//Ap√©ndice

//Herencia protot√≠pica

//Con la excepci√≥n de null y undefined, cada tipo de datos primitivo tiene un prototipo, un wrapper de objetos correspondiente que proporciona m√©todos para trabajar con valores. Cuando se invoca un m√©todo o una b√∫squeda de propiedades en una primitiva, JavaScript une la primitiva en segundo plano y llama al m√©todo o realiza la b√∫squeda de propiedades en el objeto del wrapper.

//Por ejemplo, una cadena literal no tiene m√©todos propios, pero puedes llamar al m√©todo .toUpperCase() en ella gracias al wrapper de objetos String correspondiente:

"this is a string literal".toUpperCase();
> THIS IS A STRING LITERAL
Esto se denomina herencia protot√≠pica: heredar propiedades y m√©todos del constructor correspondiente de un valor.

Number.prototype
> Number { 0 }
>  constructor: function Number()
>  toExponential: function toExponential()
>  toFixed: function toFixed()
>  toLocaleString: function toLocaleString()
>  toPrecision: function toPrecision()
>  toString: function toString()
>  valueOf: function valueOf()
>  <prototype>: Object { ‚Ä¶ }

//Puedes crear primitivas con estos constructores, en lugar de solo definirlas por su valor. Por ejemplo, usar el constructor String crea un objeto de cadena, no una cadena literal: un objeto que no solo contiene nuestro valor de cadena, sino todas las propiedades y m√©todos heredados del constructor.

const myString = new String( "I'm a string." );

myString;
> String { "I'm a string." }

typeof myString;
> "object"

myString.valueOf();
> "I'm a string."

//En su mayor√≠a, los objetos resultantes se comportan como los valores que usamos para definirlos. Por ejemplo, aunque definir un valor num√©rico con el constructor new Number genera un objeto que contiene todos los m√©todos y propiedades del prototipo Number, puedes usar operadores matem√°ticos en esos objetos de la misma manera que lo har√≠as en n√∫meros literales:

const numberOne = new Number(1);
const numberTwo = new Number(2);

numberOne;
> Number { 1 }

typeof numberOne;
> "object"

numberTwo;
> Number { 2 }

typeof numberTwo;
> "object"

numberOne + numberTwo;
> 3

//En muy raras ocasiones necesitar√°s usar estos constructores, ya que la herencia protot√≠pica integrada de JavaScript significa que no proporcionan ning√∫n beneficio pr√°ctico. Crear primitivas con constructores tambi√©n puede generar resultados inesperados, ya que el resultado es un objeto, no un literal simple:

let stringLiteral = "String literal."

typeof stringLiteral;
> "string"

let stringObject = new String( "String object." );

stringObject
> "object"
Esto puede complicar el uso de operadores de comparaci√≥n estrictos:

const myStringLiteral = "My string";
const myStringObject = new String( "My string" );

myStringLiteral === "My string";
> true

myStringObject === "My string";
> false

//Inserci√≥n autom√°tica de punto y coma (ASI)

//Mientras analizan una secuencia de comandos, los int√©rpretes de JavaScript pueden usar una funci√≥n llamada inserci√≥n autom√°tica de punto y coma (ASI) para intentar corregir instancias de puntos y coma omitidos. Si el analizador de JavaScript encuentra un token que no est√° permitido, intenta agregar un punto y coma antes de ese token para corregir el posible error de sintaxis, siempre que se cumpla una o m√°s de las siguientes condiciones:

//Ese token est√° separado del anterior por un salto de l√≠nea.
//Ese token es }.
//El token anterior es ), y el punto y coma insertado ser√≠a el punto y coma final de una sentencia do‚Ä¶while.
//Para obtener m√°s informaci√≥n, consulta las reglas de ASI.

//Por ejemplo, omitir los puntos y coma despu√©s de las siguientes instrucciones no generar√° un error de sintaxis debido a ASI:

const myVariable = 2
myVariable + 3
> 5

//Sin embargo, ASI no puede tener en cuenta varias instrucciones en la misma l√≠nea. Si escribes m√°s de una sentencia en la misma l√≠nea, aseg√∫rate de separarlas con punto y coma:

const myVariable = 2 myVariable + 3
> Uncaught SyntaxError: unexpected token: identifier

const myVariable = 2; myVariable + 3;
> 5

//ASI es un intento de correcci√≥n de errores, no un tipo de flexibilidad sint√°ctica integrada en JavaScript. Aseg√∫rate de usar punto y coma cuando corresponda para no depender de ellos para producir un c√≥digo correcto.

//Modo estricto

//Los est√°ndares que rigen la forma en que se escribe JavaScript evolucionaron mucho m√°s all√° de lo que se consider√≥ durante el dise√±o inicial del lenguaje. Cada cambio nuevo en el comportamiento esperado de JavaScript debe evitar causar errores en sitios web m√°s antiguos.

//ES5 aborda algunos problemas de larga data con la sem√°ntica de JavaScript sin romper las implementaciones existentes, ya que presenta el ‚Äúmodo estricto‚Äù, una forma de habilitar un conjunto m√°s restrictivo de reglas de lenguaje para una secuencia de comandos completa o una funci√≥n individual. Para habilitar el modo estricto, usa el literal de cadena "use strict", seguido de un punto y coma, en la primera l√≠nea de una secuencia de comandos o funci√≥n:

"use strict";
function myFunction() {
  "use strict";
}

//El modo estricto evita ciertas acciones "inseguras" o funciones obsoletas, arroja errores expl√≠citos en lugar de los comunes "silenciosos" y proh√≠be el uso de sintaxis que podr√≠an colisionar con funciones futuras del lenguaje. Por ejemplo, las primeras decisiones de dise√±o en torno al alcance de las variables aumentaron la probabilidad de que los desarrolladores "contaminaran" por error el alcance global cuando declaraban una variable, independientemente del contexto que la contiene, omitiendo la palabra clave var:

(function() {
  mySloppyGlobal = true;
}());

mySloppyGlobal;
> true

//Los tiempos de ejecuci√≥n de JavaScript modernos no pueden corregir este comportamiento sin correr el riesgo de da√±ar cualquier sitio web que lo use, ya sea por error o de forma deliberada. En cambio, el JavaScript moderno lo evita, ya que permite que los desarrolladores habiliten el modo estricto para el trabajo nuevo y lo habiliten de forma predeterminada solo en el contexto de las nuevas funciones del lenguaje en las que no se romper√°n las implementaciones heredadas:

(function() {
    "use strict";
    mySloppyGlobal = true;
}());
> Uncaught ReferenceError: assignment to undeclared variable mySloppyGlobal

//Debes escribir "use strict" como un literal de cadena. Un literal de plantilla (use strict) no funcionar√°. Tambi√©n debes incluir "use strict" antes de cualquier c√≥digo ejecutable en el contexto previsto. De lo contrario, el int√©rprete lo ignora.

(function() {
    "use strict";
    let myVariable = "String.";
    console.log( myVariable );
    sloppyGlobal = true;
}());
> "String."
> Uncaught ReferenceError: assignment to undeclared variable sloppyGlobal

(function() {
    let myVariable = "String.";
    "use strict";
    console.log( myVariable );
    sloppyGlobal = true;
}());
> "String." // Because there was code prior to "use strict", this variable still pollutes the global scope

//Por referencia y por valor

//Cualquier variable, incluidas las propiedades de un objeto, los par√°metros de funci√≥n y los elementos de un array, un conjunto o un mapa, puede contener un valor primitivo o un valor de referencia.

//Cuando se asigna un valor primitivo de una variable a otra, el motor de JavaScript crea una copia de ese valor y se la asigna a la variable.

//Cuando asignas un objeto (instancias de clase, arrays y funciones) a una variable, en lugar de crear una copia nueva de ese objeto, la variable contiene una referencia a la posici√≥n almacenada del objeto en la memoria. Por este motivo, cambiar un objeto al que hace referencia una variable cambia el objeto al que se hace referencia, no solo un valor que contiene esa variable. Por ejemplo, si inicializas una variable nueva con una variable que contiene una referencia de objeto y, luego, usas la variable nueva para agregar una propiedad a ese objeto, la propiedad y su valor se agregan al objeto original:

const myObject = {};
const myObjectReference = myObject;

myObjectReference.myProperty = true;

myObject;
> Object { myProperty: true }

//Esto es importante no solo para alterar objetos, sino tambi√©n para realizar comparaciones estrictas, ya que la igualdad estricta entre objetos requiere que ambas variables hagan referencia a el mismo objeto para evaluarse como true. No pueden hacer referencia a objetos diferentes, incluso si esos objetos son estructuralmente id√©nticos:

const myObject = {};
const myReferencedObject = myObject;
const myNewObject = {};

myObject === myNewObject;
> false

myObject === myReferencedObject;
> true

//Asignaci√≥n de memoria:

//JavaScript usa la administraci√≥n autom√°tica de memoria, lo que significa que no es necesario asignar o desasignar la memoria de forma expl√≠cita durante el desarrollo. Si bien los detalles de los enfoques de los motores de JavaScript para la administraci√≥n de la memoria exceden el alcance de este m√≥dulo, comprender c√≥mo se asigna la memoria proporciona un contexto √∫til para trabajar con valores de referencia.

//Hay dos ‚Äú√°reas‚Äù en la memoria: la ‚Äúpila‚Äù y el ‚Äúmont√≥n‚Äù. La pila almacena datos est√°ticos (valores primitivos y referencias a objetos) porque la cantidad fija de espacio necesaria para almacenar estos datos se puede asignar antes de que se ejecute la secuencia de comandos. El mont√≥n almacena objetos, que necesitan espacio asignado de forma din√°mica porque su tama√±o puede cambiar durante la ejecuci√≥n. La memoria se libera mediante un proceso llamado ‚Äúrecolecci√≥n de elementos no utilizados‚Äù, que quita de la memoria los objetos sin referencias.

//El subproceso principal

//JavaScript es un lenguaje b√°sicamente de subproceso √∫nico con un modelo de ejecuci√≥n "s√≠ncrono", lo que significa que puede ejecutar solo una tarea a la vez. Este contexto de ejecuci√≥n secuencial se denomina subproceso principal.

//Otras tareas del navegador comparten el subproceso principal, como el an√°lisis de HTML, la renderizaci√≥n y la renderizaci√≥n de nuevo de partes de la p√°gina, la ejecuci√≥n de animaciones CSS y el control de las interacciones del usuario, desde las simples (como destacar texto) hasta las complejas (como interactuar con elementos de formulario). Los proveedores de navegadores encontraron formas de optimizar las tareas que realiza el subproceso principal, pero las secuencias de comandos m√°s complejas a√∫n pueden usar demasiados recursos del subproceso principal y afectar el rendimiento general de la p√°gina.

//Algunas tareas se pueden ejecutar en subprocesos en segundo plano llamados Web Workers, con algunas limitaciones:

//Los subprocesos de trabajo solo pueden actuar en archivos JavaScript independientes.
//Tienen acceso muy reducido o nulo a la ventana del navegador y a la IU.
//Se limitan en la forma en que pueden comunicarse con el subproceso principal.
//Estas limitaciones las hacen ideales para tareas enfocadas y que requieren muchos recursos que, de otro modo, podr√≠an ocupar el subproceso principal.

//La pila de llamadas

//La estructura de datos que se usa para administrar los "contextos de ejecuci√≥n" (el c√≥digo que se ejecuta de forma activa) es una lista llamada pila de llamadas (a menudo, solo "la pila"). Cuando se ejecuta una secuencia de comandos por primera vez, el int√©rprete de JavaScript crea un "contexto de ejecuci√≥n global" y lo env√≠a a la pila de llamadas, con sentencias dentro de ese contexto global que se ejecutan de a una, de arriba hacia abajo. Cuando el int√©rprete encuentra una llamada a funci√≥n mientras ejecuta el contexto global, env√≠a un "contexto de ejecuci√≥n de la funci√≥n" para esa llamada a la parte superior de la pila, pausa el contexto de ejecuci√≥n global y ejecuta el contexto de ejecuci√≥n de la funci√≥n.

//Cada vez que se llama a una funci√≥n, el contexto de ejecuci√≥n de la funci√≥n para esa llamada se empuja a la parte superior de la pila, justo encima del contexto de ejecuci√≥n actual. La pila de llamadas funciona seg√∫n el principio "√∫ltimo en entrar, primero en salir", lo que significa que la llamada a funci√≥n m√°s reciente, que es la m√°s alta en la pila, se ejecuta y contin√∫a hasta que se resuelve. Cuando se completa esa funci√≥n, el int√©rprete la quita de la pila de llamadas, y el contexto de ejecuci√≥n que contiene esa llamada a funci√≥n vuelve a ser el elemento m√°s alto de la pila y reanuda la ejecuci√≥n.

//Estos contextos de ejecuci√≥n capturan cualquier valor necesario para su ejecuci√≥n. Tambi√©n establecen las variables y funciones disponibles dentro del alcance de la funci√≥n seg√∫n su contexto superior, y determinan y establecen el valor de la palabra clave this en el contexto de la funci√≥n.

//El bucle de eventos y la cola de devoluci√≥n de llamada

//Esta ejecuci√≥n secuencial significa que las tareas as√≠ncronas que incluyen funciones de devoluci√≥n de llamada, como recuperar datos de un servidor, responder a la interacci√≥n del usuario o esperar a los temporizadores establecidos con setTimeout o setInterval, bloquear√≠an el subproceso principal hasta que se complete esa tarea o interrumpir√≠an de forma inesperada el contexto de ejecuci√≥n actual en el momento en que se agregue el contexto de ejecuci√≥n de la funci√≥n de devoluci√≥n de llamada a la pila. Para abordar este problema, JavaScript administra tareas as√≠ncronas con un ‚Äúmodelo de simultaneidad‚Äù basado en eventos que consta del ‚Äúbucle de eventos‚Äù y la ‚Äúcola de devoluci√≥n de llamada‚Äù (a veces, denominada ‚Äúcola de mensajes‚Äù).

//Cuando se ejecuta una tarea as√≠ncrona en el subproceso principal, el contexto de ejecuci√≥n de la funci√≥n de devoluci√≥n de llamada se coloca en la cola de devoluci√≥n de llamada, no en la parte superior de la pila de llamadas. El bucle de eventos es un patr√≥n que, a veces, se denomina reactor, que sondea de forma continua el estado de la pila de llamadas y la cola de devoluciones de llamada. Si hay tareas en la fila de devoluci√≥n de llamada y el bucle de eventos determina que la pila de llamadas est√° vac√≠a, las tareas de la fila de devoluci√≥n de llamada se env√≠an a la pila de a una a la vez para que se ejecuten.
</script>
</body>
</html>