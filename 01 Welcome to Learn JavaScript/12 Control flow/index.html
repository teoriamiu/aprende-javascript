<!DOCTYPE html>
<html>
<body>
<h2>üòç ¬°Flujo de control!</h2>
<script>
/*# Flujo de control

El *flujo de control* es el orden en el que el int√©rprete de JavaScript ejecuta las sentencias. Si un script no incluye sentencias que alteren su flujo, se ejecuta de principio a fin, una l√≠nea a la vez. Las *estructuras de control* se utilizan para determinar si un conjunto de sentencias se ejecuta o no seg√∫n un conjunto definido de criterios, ejecutar un conjunto de sentencias repetidamente, o interrumpir una secuencia de sentencias.

## Sentencias condicionales

Las sentencias condicionales determinan si se debe ejecutar c√≥digo bas√°ndose en una o m√°s condiciones. Una sentencia condicional ejecuta el c√≥digo que contiene si la condici√≥n (o conjunto de condiciones) asociada se eval√∫a como `true`. De lo contrario, el c√≥digo se omite.

### `if`...`else`

Una sentencia `if` eval√∫a una condici√≥n dentro de los par√©ntesis coincidentes que la siguen. Si la condici√≥n dentro de los par√©ntesis se eval√∫a como `true`, se ejecuta la sentencia o sentencia de bloque que sigue a los par√©ntesis coincidentes:*/

{
    if ( true ) console.log( "Verdadero." );
    //> "Verdadero."
}
{
    if ( true ) {
        const miCadena = "Verdadero.";
        console.log( miCadena );
    }
    //> "Verdadero."
}

//Si la condici√≥n dentro de los par√©ntesis se eval√∫a como `false`, la sentencia que la sigue se ignora:

    if ( false ) console.log( "Verdadero." );

//Una palabra clave `else` inmediatamente despu√©s de una sentencia `if` y su sentencia ejecutada condicionalmente especifica la sentencia a ejecutar si la condici√≥n `if` se eval√∫a como `false`:

{
    if ( false ) console.log( "Verdadero." );
    else console.log( "Falso." );
    //> "Falso."
}

//Para encadenar m√∫ltiples sentencias `if`, puedes hacer que la sentencia ejecutada condicionalmente despu√©s de `else` sea otra sentencia `if`:

{
    const miCondicion = 2;
    if ( miCondicion === 5 ) console.log( "Cinco." );
    else if ( miCondicion === 2 ) console.log( "Dos." );
}

//Recomendamos encarecidamente usar la sintaxis de sentencia de bloque despu√©s de los condicionales para mejorar la legibilidad, pero las cl√°usulas `else if` son a menudo una excepci√≥n a esto:

{
    const miCondicion = 2;
    if ( miCondicion === 5 ) {
        console.log( "Cinco." );
    } else if ( miCondicion === 3 ) {
        console.log( "Tres." );
    } else {
        console.log( "Ni cinco ni tres." );
    }
   // > "Ni cinco ni tres."
}

//#### Operador ternario

//`if` ejecuta condicionalmente una sentencia. El operador ternario (m√°s precisamente, aunque menos com√∫nmente, llamado *operador condicional ternario*) es una abreviatura utilizada para ejecutar condicionalmente una expresi√≥n. Como su nombre indica, el operador ternario es el √∫nico operador de JavaScript que utiliza tres operandos:

//- Una condici√≥n a evaluar, seguida de un signo de interrogaci√≥n (`?`).
//- La expresi√≥n a ejecutar si la condici√≥n se eval√∫a como `true`, seguida de dos puntos (`:`).
//- La expresi√≥n a ejecutar si la condici√≥n se eval√∫a como `false`.

//Esto se usa frecuentemente para establecer o pasar un valor condicionalmente:

{
    const miPrimerResultado  = true  ? "Primer valor." : "Segundo valor.";
    const miSegundoResultado = false ? "Primer valor." : "Segundo valor.";

    console.log(miPrimerResultado);
   // > "Primer valor."

    console.log(miSegundoResultado);
    //> "Segundo valor."
}

//### `switch`...`case`

//Utiliza la sentencia `switch` para comparar el valor de una expresi√≥n con una lista de valores potenciales definidos mediante una o m√°s palabras clave `case`. Esta sintaxis es inusual porque proviene de algunas de las primeras decisiones de dise√±o de JavaScript. La sintaxis `switch`...`case` utiliza la palabra clave `switch`, seguida de una expresi√≥n a evaluar encerrada entre par√©ntesis, seguida de un par de llaves coincidentes. El cuerpo del `switch` puede contener palabras clave `case`, normalmente una o m√°s, seguidas de una expresi√≥n o valor, seguidas de dos puntos (`:`).

//Cuando el int√©rprete alcanza un `case` con un valor que coincide con la expresi√≥n que se est√° evaluando en los par√©ntesis despu√©s de la palabra clave `switch`, ejecuta cualquier sentencia que siga a esa cl√°usula `case`:

{
    switch ( 2 + 2 === 4 ) {
      case false:
        console.log( "Falso." );
      case true:
        console.log( "Verdadero." );
    }
    //> "Verdadero."
}

//Todas las sentencias que siguen al `case` coincidente se ejecutan, incluso si est√°n encerradas en una sentencia de bloque:

{
    switch ( 2 + 2 === 4 ) {
        case false:
        console.log( "Falso." );
      case true:
        let miVariable = "Verdadero.";
        console.log( miVariable );

    }
    //> "Verdadero."
}

//Un problema de usar `switch...case` es que, despu√©s de encontrar una coincidencia, el int√©rprete de JavaScript ejecuta *cualquier* sentencia que siga al `case` coincidente, incluso aquellas dentro de otras cl√°usulas `case`. Esto se llama "caer a trav√©s" (fall through) al siguiente `case`:

{
    switch ( 2 + 2 === 7 ) {
        case false:
        console.log( "Falso." );
      case true:
        console.log( "Verdadero." );
    }
   // > "Falso."
   // > "Verdadero."
}

//Para evitar la ca√≠da a trav√©s, finaliza cada caso con la palabra clave `break`, que detiene inmediatamente la evaluaci√≥n del cuerpo del `switch`:

{
    switch ( 2 + 2 === 7 ) {
        case false:
        console.log( "Falso." );
        break;
      case true:
        console.log( "Verdadero." );
        break;
    }
    //> "Falso."
}

//Si ning√∫n `case` coincide con el valor condicional, el `switch` selecciona la cl√°usula `default` si existe:

{
    switch ( 20 ) {
        case 5:
        console.log( "El valor era cinco." );
        break;
      case 10:
        console.log( "El valor era diez." );
        break;
      default:
        console.log( "El valor era algo inesperado." );
    }
    //> "El valor era algo inesperado."
}

//Sin embargo, la ca√≠da a trav√©s tambi√©n se aplica a `default`, lo que puede llevar a resultados inesperados. Para solucionarlo, termina tu sentencia `default` con `break`, o col√≥cala al final de la lista de casos.
{
    switch ( 20 ) {
      default:
        console.log( "El valor era algo inesperado." );
      case 10:
        console.log( "El valor era diez." );
        break;
      case 5:
        console.log( "El valor era cinco." );
        break;
    }
   // > "El valor era algo inesperado."
   // > "El valor era diez."
}

//Debido a que las cl√°usulas `case` no requieren una sentencia de bloque para agrupar m√∫ltiples sentencias, las cl√°usulas `case` y `default` no crean √°mbito l√©xico por s√≠ mismas:

{
   /* let miVariable;
    switch ( true ) {
      case true:
        let miVariable = "Verdadero.";
        break;
      default:
        let miVariable = "Falso.";
        break;
    }
    //> Uncaught SyntaxError: redeclaration of let miVariable */
}

//Para gestionar el √°mbito, utiliza sentencias de bloque:

{
    let miVariable;

switch (true) {
    case true: {
        miVariable = "Verdadero.";
        console.log(miVariable);
        break;
    }
    default: {
        miVariable = "Falso.";
        console.log(miVariable);
        break;
    }
}
}

//## Bucles e iteraci√≥n

//Los bucles te permiten repetir un conjunto de sentencias mientras se cumpla una condici√≥n, o hasta que se cumpla una condici√≥n. Utiliza bucles para ejecutar un conjunto de instrucciones un n√∫mero fijo de veces, hasta lograr un resultado espec√≠fico, o hasta que el int√©rprete llegue al final de una estructura de datos iterable (por ejemplo, el elemento final en un array, mapa o conjunto, la propiedad final de un objeto, o el √∫ltimo car√°cter en una cadena).

//Los bucles interrumpen el flujo de ejecuci√≥n "de arriba abajo" de un script al iterar sobre un conjunto de sentencias hasta que se cumplan una o m√°s condiciones, o dejen de cumplirse, dependiendo de la sintaxis utilizada para crear el bucle. Despu√©s de que el bucle termina, la ejecuci√≥n contin√∫a con las sentencias que le siguen. En el siguiente ejemplo, las sentencias en el cuerpo del bucle se ejecutan tres veces antes de que el int√©rprete contin√∫e:

{
    let contadorIteraciones = 0;
    console.log( "Antes del bucle." );
    while( contadorIteraciones < 9 ) {
      contadorIteraciones++;
      console.log( "Iteraci√≥n del bucle." );
    }
    console.log( "Continuando." );
    /*> "Antes del bucle."
    > "Iteraci√≥n del bucle."
    > "Iteraci√≥n del bucle."
    > "Iteraci√≥n del bucle."
    > "Continuando."*/
}

//Si las condiciones no se pueden cumplir durante la ejecuci√≥n del bucle, el bucle contin√∫a indefinidamente. Estos *bucles infinitos* son un error de programaci√≥n com√∫n que puede hacer que el hilo de ejecuci√≥n principal se pause indefinidamente, o incluso bloquear una pesta√±a del navegador.

//El siguiente ejemplo se ejecuta mientras el valor booleano `true` permanezca `true`. Debido a que los valores booleanos son inmutables, esto crea un bucle infinito.
//**Advertencia:** ejecutar el siguiente c√≥digo puede ralentizar tu navegador o bloquear la pesta√±a actual del navegador.

    console.log( "Antes del bucle." );
    /*while( true === 3) {
        console.log( "Iteraci√≥n del bucle." );
    }
    > "Antes del bucle."
    > "Iteraci√≥n del bucle."
    > "Iteraci√≥n del bucle."
    > "Iteraci√≥n del bucle."
    > "Iteraci√≥n del bucle."
    > "Iteraci√≥n del bucle."
    ...*/

//Evita dejar bucles infinitos en tu c√≥digo de producci√≥n. Si accidentalmente creas uno durante el desarrollo, puedes solucionarlo cerrando la pesta√±a del navegador en la que se est√° ejecutando, actualizando tu c√≥digo para que el bucle ya no sea infinito, y volviendo a abrir la p√°gina.

//### `while`

//Un bucle `while` se crea usando la palabra clave `while` seguida de un par de par√©ntesis coincidentes que contienen una condici√≥n a evaluar. Si la condici√≥n especificada inicialmente se eval√∫a como `true`, se ejecuta la sentencia (o sentencia de bloque) que sigue a esos par√©ntesis. Si no, el bucle nunca se ejecuta. Despu√©s de cada iteraci√≥n, la condici√≥n se reeval√∫a, y si a√∫n es `true`, el bucle se repite.

{
    let contadorIteraciones = 0;
    while( contadorIteraciones < 3 ) {
      contadorIteraciones++;
      console.log( `Bucle ${ contadorIteraciones }.` );
    }
    /*> "Bucle 1."
    > "Bucle 2."
    > "Bucle 3."*/
}

//Si el int√©rprete encuentra una sentencia `continue` en un bucle `while`, detiene esa iteraci√≥n, reeval√∫a la condici√≥n y contin√∫a el bucle si es posible:

{
    let contadorIteraciones = 0;
    while( contadorIteraciones <= 5 ) {
      contadorIteraciones++;
      if( contadorIteraciones === 3 ) {
        continue;
      }
      console.log( `Bucle ${ contadorIteraciones }.` );
    }
    console.log( "Bucle terminado." );
   /* > "Bucle 1."
    > "Bucle 2."
    > "Bucle 4."
    > "Bucle 5."
    > "Bucle 6."
    > "Bucle terminado."*/
}

//Si el int√©rprete encuentra una sentencia `break` en un bucle `while`, esa iteraci√≥n se detiene y la condici√≥n no se reeval√∫a, permitiendo que el int√©rprete contin√∫e:

{
    let contadorIteraciones = 1;
while( contadorIteraciones <= 5 ) {
      if( contadorIteraciones === 3 ) {
        console.log( `Iteraci√≥n omitida.` );
        break;
      }
      console.log( `Bucle ${ contadorIteraciones }.` );
      contadorIteraciones++;
    }
    console.log( "Bucle terminado." );
}
    /*> "Bucle 1."
    > "Bucle 2."
    > "Iteraci√≥n omitida."
    > "Bucle terminado."*/

//Puedes usar `while` para iterar un n√∫mero espec√≠fico de veces, como se ve en el ejemplo anterior, pero el caso de uso m√°s com√∫n para `while` es un bucle de longitud indeterminada:

{
    let aleatorio = () => Math.floor( Math.random() * 10 );
    let numeroAleatorio = aleatorio();
    while( numeroAleatorio !== 3 ){
      console.log( `El n√∫mero no es ${ numeroAleatorio }.` );
      numeroAleatorio = aleatorio();
    }
    console.log( `El n√∫mero correcto, ${ numeroAleatorio }, fue encontrado.` );
    /*> "El n√∫mero no es 0."
    > "El n√∫mero no es 6."
    > "El n√∫mero no es 1."
    > "El n√∫mero no es 8."
    > "El n√∫mero correcto, 3, fue encontrado."*/
    }

//### `do`...`while`

//`do`...`while` es una variante del bucle `while` en la que la evaluaci√≥n condicional ocurre al *final* de cada iteraci√≥n del bucle. Esto significa que el cuerpo del bucle siempre se ejecuta al menos una vez.

//Para crear un bucle `do`...`while`, usa la palabra clave `do` seguida de la sentencia (o sentencia de bloque) a ejecutar en cada iteraci√≥n del bucle. Inmediatamente despu√©s de esa sentencia, a√±ade `while` y los par√©ntesis coincidentes que contienen la condici√≥n a evaluar. Cuando esta condici√≥n deje de evaluarse como `true`, el bucle termina.

{
    let contadorIteraciones = 1;
    do {
      console.log( `Bucle ${ contadorIteraciones }.` );
      contadorIteraciones++;
    } while ( contadorIteraciones < 3 );
   /* > "Bucle 1."
    > "Bucle 2."
    > "Bucle 3."*/
}

//Al igual que con un bucle `while`, el caso de uso m√°s com√∫n para `do`...`while` es un bucle de longitud indeterminada:

{
    let numeroAleatorio;
    do {
      numeroAleatorio = ( () => Math.floor( Math.random() * 10 ) )();
      console.log( `¬øEs el n√∫mero ${ numeroAleatorio }?` );
    } while ( numeroAleatorio !== 3 );
    console.log( `S√≠, ${ numeroAleatorio } era el n√∫mero correcto.` );
    /*> "¬øEs el n√∫mero 9?"
    > "¬øEs el n√∫mero 2?"
    > "¬øEs el n√∫mero 8?"
    > "¬øEs el n√∫mero 2?"
    > "¬øEs el n√∫mero 3?"
    > "S√≠, 3 era el n√∫mero correcto."*/
}

//### `for`

//Utiliza bucles `for` para iterar sobre una cantidad conocida. En bases de c√≥digo heredadas, esto se usaba frecuentemente para iterar sobre los elementos de un array.

//Para crear un bucle `for`, usa la palabra clave `for`, seguida de un conjunto de par√©ntesis que acepta las siguientes tres expresiones en orden y separadas por punto y coma:

//1. Una expresi√≥n a evaluar cuando el bucle comienza
//2. Una condici√≥n que determina si el bucle debe continuar
//3. Una expresi√≥n a ejecutar al concluir cada bucle

//Despu√©s de estos par√©ntesis, a√±ade la sentencia (t√≠picamente una sentencia de bloque) a ejecutar durante el bucle.

    for( let i = 0; i < 3; i++ ) {
      console.log( "Este bucle se ejecutar√° tres veces." )
    }

//La primera expresi√≥n inicializa una variable que act√∫a como contador. Esta expresi√≥n se eval√∫a una vez, antes de la primera iteraci√≥n del bucle. Puedes inicializar esta variable usando `let` (o `var`, hist√≥ricamente) como cualquier otra variable, y su √°mbito es el cuerpo del bucle. Estas variables pueden tener cualquier identificador v√°lido, pero frecuentemente se llaman `i` por "iteraci√≥n" o "√≠ndice". Esto parece contradecir las mejores pr√°cticas establecidas para nombres de identificadores predecibles, pero la convenci√≥n est√° lo suficientemente establecida como para ser clara para otros desarrolladores de un vistazo. Debido a que las colecciones indexadas tienen base cero, estas variables casi siempre tienen un valor inicial de `0`.

//Al igual que con otras formas de bucle, la condici√≥n es una expresi√≥n que determina si el bucle debe ejecutarse. Esto se usa m√°s a menudo para establecer un l√≠mite superior para el contador de iteraci√≥n. El int√©rprete eval√∫a la condici√≥n antes de ejecutar el bucle `for` por primera vez. Si la condici√≥n no se eval√∫a inicialmente como `true`, el cuerpo del bucle no se ejecuta.

//La expresi√≥n final se ejecuta al final de cada iteraci√≥n del bucle. T√≠picamente se usa para incrementar el identificador en uno.

//Ver√°s m√°s com√∫nmente bucles `for` iterando sobre arrays en bases de c√≥digo m√°s antiguas. En estos casos, la condici√≥n especificada para continuar el bucle es un contador de iteraci√≥n menor o igual a la longitud del array que se est√° iterando. La variable utilizada para rastrear el contador de iteraci√≥n actual se usa para buscar el valor asociado con ese √≠ndice en el array, permitiendo que cada elemento del array sea procesado en orden:

{
    var miArray = [ true, false, true ];
    for( let i = 0; i < miArray.length; i++ ) {
      console.log( miArray[ i ] );
    }
    /*> true
    > false
    > true*/
}

//Este enfoque ha ca√≠do en desuso en favor de enfoques m√°s modernos para recorrer estructuras de datos iterables.

//#### `for` \[...\] `of` \[...\]

//Usa bucles `for`...`of`... para iterar sobre los valores almacenados en una estructura de datos iterable, como un array, conjunto (set) o mapa (map).

//Un bucle `for`...`of`... utiliza la palabra clave `for` seguida de un conjunto de par√©ntesis que contiene una variable, seguida de `of`, y luego la estructura de datos sobre la que se itera. La variable puede ser una declaraci√≥n realizada aqu√≠ usando `let`, `const` o `var`, una variable declarada previamente dentro del √°mbito actual, una propiedad de objeto, o una instancia de asignaci√≥n por desestructuraci√≥n. Contiene el valor del elemento que corresponde con la iteraci√≥n actual del bucle.

{
    const miIterable = [ true, false, true ];
    for( const miElemento of miIterable ) {
      console.log( miElemento );
    }
    /*> true
    > false
    > true*/
}

//En este ejemplo, usar `const` para `miElemento` funciona aunque a `miElemento` se le asigna un nuevo valor en cada iteraci√≥n del bucle. Esto se debe a que las variables declaradas con `let` o `const` tienen √°mbito en la sentencia de bloque dentro del bucle. La variable se inicializa al inicio de cada iteraci√≥n y se elimina al final de esa iteraci√≥n.

//#### `for`...`in`...

//Usa bucles `for`...`in`... para iterar sobre las propiedades enumerables de un objeto, incluyendo propiedades enumerables heredadas. Al igual que un bucle `for`...`of`..., un bucle `for`...`in`... utiliza la palabra clave `for` seguida de un conjunto de par√©ntesis que contiene una variable que contiene el valor de la clave de la propiedad correspondiente a la iteraci√≥n actual del bucle. Esta variable va seguida de la palabra clave `in`, y luego el objeto sobre el que se itera:

{
    const miObjeto = { "miPropiedad" : true, "miSegundaPropiedad" : false };
    for( const miClave in miObjeto ) {
      console.log( miClave );
    }
    //> "miPropiedad"
    //> "miSegundaPropiedad"
}

//Nuevamente, a pesar de que el valor de `miClave` cambia con cada iteraci√≥n del bucle, puedes usar `const` sin error porque la variable se descarta efectivamente al final de cada iteraci√≥n y se recrea al inicio.

//El valor asociado con cada clave de propiedad no est√° directamente disponible en la sintaxis `for`...`in`... Sin embargo, debido a que el bucle tiene acceso a la clave de la propiedad en cada iteraci√≥n, puedes usar esa clave para "buscar" su valor:

{
    const miObjeto = { "miPropiedad" : true, "miSegundaPropiedad" : false };
    for( const miClave in miObjeto ) {
      const miValor = miObjeto[ miClave ];
      console.log( `${ miClave } : ${ miValor }` );
    }
    //> "miPropiedad : true"
    //> "miSegundaPropiedad : false"
}

//Las propiedades heredadas de constructores incorporados son no enumerables, lo que significa que `for`...`in`... no itera a trav√©s de las propiedades heredadas del constructor `Object`. Sin embargo, se incluyen cualesquiera propiedades enumerables dentro de la cadena de prototipos del objeto:

{
    const miPrototipo = { "propiedadProto" : true };
    const miObjeto = Object.create( miPrototipo, {
        miPropiedad: {
            value: true,
            enumerable: true
        }
    });
    for ( const miClave in miObjeto ) {
      const miValor = miObjeto[ miClave ];
      console.log( `${ miClave } : ${ miValor }` );
    }
    //> "miPropiedad : true"
   // > "propiedadProto : true"
}

//JavaScript proporciona m√©todos integrados para determinar si una propiedad es una propiedad directa del objeto en lugar de una propiedad en la cadena de prototipos del objeto: el m√©todo moderno `Object.hasOwn()` y el m√©todo heredado `Object.prototype.hasOwnProperty()`. Estos m√©todos eval√∫an si una propiedad especificada es heredada (o no declarada), devolviendo `true` solo para las propiedades inmediatas de un objeto especificado:

{
    const miPrototipo = { "propiedadProto" : true };
    const miObjeto = Object.create( miPrototipo, {
        miPropiedad: {
            value: true,
            enumerable: true
        }
    });
    for ( const miClave in miObjeto ) {
      const miValor = miObjeto[ miClave ];
      if ( Object.hasOwn( miObjeto, miClave ) ) {
        console.log( `${ miClave } : ${ miValor }` );
      }
    }
    //> "miPropiedad : true"
}

//Tambi√©n hay tres m√©todos est√°ticos que devuelven un Array compuesto por las claves enumerables de un Objeto (`Object.keys()`), los valores enumerables (`Object.values()`), o los pares clave-valor enumerables (`Object.entries()`):

{
    const miObjeto = { "miPropiedad" : true, "miSegundaPropiedad" : false };
    Object.keys( miObjeto );
    //> Array [ "miPropiedad", "miSegundaPropiedad" ]
}

//Esto te permite iterar sobre las claves, valores o pares clave-valor de un Objeto (usando asignaci√≥n por desestructuraci√≥n) sin incluir las propiedades que pertenecen al prototipo de ese Objeto:

{
    const miPrototipo = { "propiedadProto" : "Valor de propiedad no enumerable." };
    const miObjeto = Object.create( miPrototipo, {
        miPropiedad: {
            value: "Valor de propiedad enumerable.",
            enumerable: true
        }
    });

    for ( const claveProp of Object.keys( miObjeto ) ) {
      console.log( claveProp );
    }
   // > "miPropiedad"

    for ( const valorProp of Object.values( miObjeto ) ) {
      console.log( valorProp );
    }
   // > "Valor de propiedad enumerable."

    for ( const [ claveProp, valorProp ] of Object.entries( miObjeto ) ) {
      console.log( `${ claveProp } : ${ valorProp }` );
    }
   // > "miPropiedad : Valor de propiedad enumerable."
}

//#### `forEach()`

//Los m√©todos `forEach()` proporcionados por los constructores Array, Map, Set y NodeList ofrecen una abreviatura √∫til para iterar sobre una estructura de datos en el contexto de una funci√≥n de callback. A diferencia de otras formas de bucle, un bucle creado con cualquier m√©todo `forEach()` no puede interrumpirse usando `break` o `continue`.

//`forEach` es un m√©todo que posee el prototipo de cada estructura de datos. Cada m√©todo `forEach` espera una funci√≥n de callback como argumento, aunque var√≠an ligeramente en cuanto a los argumentos incluidos cuando se llama a esa funci√≥n. Un segundo argumento opcional especifica un valor `this` para usar como contexto de invocaci√≥n para la funci√≥n de callback.

//La funci√≥n de callback utilizada con `Array.forEach` proporciona par√°metros que contienen el valor del elemento actual, el √≠ndice del elemento actual y el array sobre el cual se invoc√≥ el m√©todo `forEach`:

{
    const miArray = [ true, false ];
    miArray.forEach( ( miElemento, i, arrayOriginal ) => {
      console.log( i, miElemento, arrayOriginal  );
    });
    //> 0 true Array(3) [ true, false ]
   // > 1 false Array(3) [ true, false ]
}

//La funci√≥n de callback utilizada con `Map.forEach` proporciona par√°metros que contienen el valor asociado con el elemento actual, la clave asociada con el elemento actual y el Map sobre el cual se invoc√≥ el m√©todo `forEach`:

{
    const miMapa = new Map([
      ['miClave', true],
      ['miSegundaClave', false ],
    ]);
    miMapa.forEach( ( miValor, miClave, mapaOriginal ) => {
        console.log( miValor, miClave, mapaOriginal  );
    });
    //> true "miClave" Map { miClave ‚Üí true, miSegundaClave ‚Üí false }
    //> false "miSegundaClave" Map { miClave ‚Üí true, miSegundaClave ‚Üí false }
}

//Un callback de `Set.forEach` incluye par√°metros similares. Debido a que Set no tiene √≠ndices o claves distintas de los valores, el segundo argumento proporciona un valor redundante e ignorable, estrictamente para mantener la sintaxis consistente con los otros m√©todos `forEach`:

{
    const miSet = new Set([ true, false ]);
    miSet.forEach( ( miValor, miClave, setOriginal ) => {
      console.log( miValor, miClave, setOriginal  );
    });
    //> true true Set [ true, false ]
    //> false false Set [ true, false ]
}

//### Iteradores

//Un *iterable* es cualquier estructura de datos compuesta por elementos individuales que se puede iterar utilizando los enfoques detallados anteriormente. Un *iterador* es un objeto iterable que sigue el *protocolo de iterador*, lo que significa que debe implementar un m√©todo `next()` que avance a trav√©s de los elementos que contiene uno a la vez, cada vez que se llama a ese m√©todo, devolviendo un objeto para cada elemento secuencial en un formato espec√≠fico.

//Las estructuras de datos iterables integradas de JavaScript (como Array, Map y Set) no son iteradores en s√≠ mismas, pero todas heredan un m√©todo `iterator`, accesible mediante el S√≠mbolo conocido `@@iterator`, que devuelve un objeto iterador creado a partir de la estructura de datos iterable:

{
    const miIterable = [ 1, 2, 3 ];
    const miIterador = miIterable[ Symbol.iterator ]();

    console.log(miIterable);
    //> (3) [1, 2, 3]

    console.log(miIterador);
    //> Array Iterator {}
}

Llamar al m√©todo `next()` en un iterador avanza a trav√©s de los elementos que contiene uno a la vez, y cada llamada devuelve un objeto que contiene dos propiedades: `value`, que contiene el valor del elemento actual, y `done`, un booleano que nos indica si el iterador ha pasado el √∫ltimo elemento en la estructura de datos. El valor de `done` es `true` solo cuando una llamada a `next()` resulta en un intento de acceder a un elemento m√°s all√° del √∫ltimo elemento en el iterador.

    const miIterable = [ 1, 2, 3 ];
    const miIterador = miIterable[ Symbol.iterator ]();

    miIterador.next();
    > Object { value: 1, done: false }

    miIterador.next();
    > Object { value: 2, done: false }

    miIterador.next();
    > Object { value: 3, done: false }

    miIterador.next();
    > Object { value: undefined, done: true }

#### Funciones generadoras

Utiliza la palabra clave `function*` (n√≥tese el asterisco) para declarar una funci√≥n generadora o definir una expresi√≥n de funci√≥n generadora:

    function* miFuncionGeneradora() { };

Al igual que los iteradores, las funciones generadoras mantienen estado. Llamar a una funci√≥n generadora devuelve un nuevo objeto Generator pero no inmediatamente ejecuta el c√≥digo en el cuerpo de la funci√≥n:

    function* miFuncionGeneradora() {
      console.log( "Cuerpo de la funci√≥n generadora." )
    };
    const miObjetoGenerador = miFuncionGeneradora();

    miObjetoGenerador;
    > Generator {  }

    typeof miObjetoGenerador;
    > "object"

Los objetos Generator siguen el protocolo de iterador. El valor que devuelve cada llamada a `next()` en una funci√≥n generadora est√° determinado por una expresi√≥n `yield`, que pausa la ejecuci√≥n de la funci√≥n generadora y devuelve el valor de la expresi√≥n que contiene la palabra clave `yield`. Las llamadas posteriores a `next()` contin√∫an la ejecuci√≥n de la funci√≥n, paus√°ndose en la siguiente expresi√≥n `yield` y devolviendo el valor asociado.

    function* miFuncionGeneradora() {
      yield "Mi primer valor producido.";
      yield "Mi segundo valor producido.";
    };
    const miObjetoGenerador = miFuncionGeneradora();

    miObjetoGenerador.next();
    > Object { value: "Mi primer valor producido.", done: false }

    miObjetoGenerador.next();
    > Object { value: "Mi segundo valor producido.", done: false }

Cuando se llama a `next()` despu√©s de que no se especifiquen m√°s valores usando `yield`, `return` o `throw` (en caso de error), el resto del cuerpo de la funci√≥n se ejecuta, y el objeto devuelto tiene un `value` de `undefined` y una propiedad `done` con valor `true`:

    function* miFuncionGeneradora() {
        console.log( "Inicio de la funci√≥n generadora." );
        yield "Primero";
        console.log( "Segunda parte de la funci√≥n generadora." );
        yield "Segundo";
        console.log( "Tercera parte de la funci√≥n generadora." );
        yield "Tercero";
    };
    const miObjetoGenerador = miFuncionGeneradora();

    miObjetoGenerador.next();
    > "Inicio de la funci√≥n generadora."
    > Object { value: "Primero", done: false }

    miObjetoGenerador.next();
    > "Segunda parte de la funci√≥n generadora."
    > Object { value: "Segundo", done: false }

    miObjetoGenerador.next();
    > "Tercera parte de la funci√≥n generadora."
    > Object { value: "Tercero", done: false }

    miObjetoGenerador.next();
    > Object { value: undefined, done: true }

Usa `next()` solo en el objeto que devuelve la funci√≥n generadora, no en la funci√≥n generadora misma. De lo contrario, cada llamada a la funci√≥n generadora crea un nuevo objeto Generator:

    function* miFuncionGeneradora() {
      yield "Primero";
      yield "Segundo";
    };

    miFuncionGeneradora().next();
    > Object { value: "Primero", done: false }

    miFuncionGeneradora().next();
    > Object { value: "Primero", done: false }

Como con cualquier funci√≥n, la funci√≥n generadora se detiene cuando encuentra una palabra clave `return`. Luego devuelve un objeto al contexto invocador que contiene el valor retornado y una propiedad `done` con el valor `true`.

    function* miFuncionGeneradora() {
      yield 1;
      yield 2;
      return 3;
    };
    const miObjetoGenerador = miFuncionGeneradora();

    miObjetoGenerador.next();
    > Object { value: 1, done: false }

    miObjetoGenerador.next();
    > Object { value: 2, done: false }

    miObjetoGenerador.next();
    > Object { value: 3, done: true }

Una expresi√≥n `yield` puede adoptar algunas de las sem√°nticas de un identificador, permitiendo una "comunicaci√≥n" bidireccional desde y hacia la porci√≥n suspendida de la funci√≥n generadora. Cuando se pasa un valor al m√©todo `next()` de un generador como argumento, reemplaza el valor asociado con la expresi√≥n `yield` anterior y suspendida:

    function* miFuncionGeneradora() {
        const primerYield = yield;
        yield primerYield + 10;
    };
    const miObjetoGenerador = miFuncionGeneradora();

    miObjetoGenerador.next();
    > Object { value: undefined, done: false }

    miObjetoGenerador.next( 5 );
    > Object { value: 15, done: false }

Ten en cuenta que esto reemplaza la expresi√≥n completa asociada con el `yield` anterior, y no solo reasigna el valor del `yield` anterior al valor especificado en `next()`:

    function* miFuncionGeneradora() {
        const primerYield = yield;
        const segundoYield = yield primerYield + 100;
        yield segundoYield + 10;
    };
    const miObjetoGenerador = miFuncionGeneradora();

    miObjetoGenerador.next();
    > Object { value: undefined, done: false }

    miObjetoGenerador.next( 10 ); // Puede pensarse como cambiar el valor de la variable `primerYield` a `10`
    > Object { value: 110, done: false }

    miObjetoGenerador.next( 20 ); // Puede pensarse como cambiar el valor de la variable `segundoYield` a `20`, _no_ `20 + 100;`
    > Object { value: 30, done: false }

Cualquier argumento pasado a la primera llamada a `next()` se ignora, porque no hay una expresi√≥n `yield` anterior que acepte ese valor. Como con cualquier otra funci√≥n, los argumentos pasados a la llamada inicial de la funci√≥n generadora est√°n disponibles en todo el √°mbito del cuerpo de la funci√≥n generadora:

    function* miFuncionGeneradora( valorInicial ) {
        let nuevoValor = yield valorInicial + 1;
        nuevoValor = yield nuevoValor + 10;
        yield valorInicial + 20;
    };
    const miObjetoGenerador = miFuncionGeneradora( 2 );

    miObjetoGenerador.next( 1 );
    > Object { value: 3, done: false }

    miObjetoGenerador.next( 5 );
    > Object { value: 15, done: false }

    miObjetoGenerador.next( 10 );
    Object { value: 22, done: false }

El operador `yield*` (n√≥tese el asterisco) se utiliza con un iterable, como otra funci√≥n generadora, para iterar sobre y producir cada valor que devuelve su operando:

    function* miGeneradorSecundario() {
      yield 2;
      yield 3;
    }

    function* miGenerador() {
      yield 1;
      yield* miGeneradorSecundario();
      yield 4;
      return 5;
    }

    const miIterador = miGenerador();

    miIterador.next();
    > Object { value: 1, done: false }

    miIterador.next();
    > Object { value: 2, done: false }

    miIterador.next();
    > Object { value: 3, done: false }

    miIterador.next();
    > Object { value: 4, done: false }

    miIterador.next();
    > Object { value: 5, done: true }

## JavaScript as√≠ncrono

Aunque JavaScript es fundamentalmente s√≠ncrono en su ejecuci√≥n, existen mecanismos que permiten a los desarrolladores aprovechar el bucle de eventos para realizar tareas as√≠ncronas.

### Promesas

Una Promesa (Promise) es un marcador de posici√≥n para un valor que no se conoce cuando se crea la promesa. Es un contenedor que dicta una operaci√≥n as√≠ncrona, los t√©rminos por los cuales la operaci√≥n se considera un √©xito o un fracaso, las acciones a tomar en cada caso y el valor resultante.

Crea una instancia de Promise usando el operador `new` con la funci√≥n constructora `Promise` incorporada. Este constructor acepta como argumento una funci√≥n llamada *ejecutor*. Esa funci√≥n ejecutora se utiliza t√≠picamente para realizar una o m√°s acciones as√≠ncronas, y luego dictar los t√©rminos bajo los cuales la Promesa debe considerarse cumplida exitosamente o rechazada. Una Promesa se define como *pendiente* mientras la funci√≥n ejecutora se est√° ejecutando. Despu√©s de que el ejecutor finaliza, una Promesa se considera *cumplida* (o *resuelta*, en algunas fuentes de documentaci√≥n) si la funci√≥n ejecutora y la acci√≥n as√≠ncrona que realiza se completan exitosamente, y *rechazada* si la funci√≥n ejecutora encuentra un error, o la acci√≥n as√≠ncrona que se realiza falla. Despu√©s de que una Promesa es cumplida o rechazada, se considera *liquidada* (settled).

    const miPromesa = new Promise( () => { });

El constructor llama a la funci√≥n ejecutora con dos argumentos. Esos argumentos son funciones que te permiten cumplir o rechazar manualmente la Promesa:

    const miPromesa = new Promise( ( cumplir, rechazar ) => { });

Las funciones utilizadas para cumplir o rechazar una Promesa se llaman con el valor resultante de la Promesa como argumento (t√≠picamente un error para el rechazo):

    const miPromesa = new Promise( ( cumplir, rechazar ) => {
      const miResultado = true;
      setTimeout(() => {
        if( miResultado === true ) {
            cumplir( "Esta Promesa fue exitosa." );    
        } else {
            rechazar( new Error( "Esta Promesa ha sido rechazada." ) );
        }
      }, 10000);
    });

    miPromesa;
    > Promise { <state>: "pending" }

    miPromesa;
    > Promise { <state>: "fulfilled", <value>: "Esta Promesa fue exitosa." }

#### Encadenamiento de Promesas

El objeto Promise resultante puede ser procesado usando los m√©todos `then()`, `catch()` y `finally()` heredados del constructor Promise. Cada uno de estos m√©todos devuelve una Promesa, que inmediatamente puede ser procesada nuevamente con `then()`, `catch()` o `finally()`, permitiendo *encadenar* las Promesas resultantes.

`then()` proporciona dos funciones de callback como argumentos. Usa la primera para cumplir la Promesa resultante, y la segunda para rechazarla. Ambos m√©todos aceptan un solo argumento que da a la Promesa resultante su valor.

    const miPromesa = new Promise( ( cumplir, rechazar ) => {
      const miResultado = true;
      setTimeout(() => {
        if( miResultado === true ) {
            cumplir( "Esta Promesa fue cumplida." );    
        } else {
            rechazar( new Error( "Esta Promesa ha sido rechazada." ) );
        }
      }, 100);
    });

    miPromesa.then( resultadoExitoso => console.log( resultadoExitoso ), resultadoFallido => console.error( resultadoFallido ) );
    > "Esta Promesa fue exitosa."

Tambi√©n puedes usar `then()` para manejar solo el estado cumplido, y `catch` para manejar el estado rechazado. Llama a `catch` con un solo argumento que contiene el valor proporcionado en el m√©todo de rechazo de la Promesa:

    const miPromesa = new Promise( ( cumplir, rechazar ) => {
      const miResultado = false;
      setTimeout(() => {
        if( miResultado === true ) {
            cumplir( "Esta Promesa fue cumplida." );    
        } else {
            rechazar( new Error( "Esta Promesa ha sido rechazada." ) );
        }
      }, 100);
    });

    miPromesa
      .then( resultadoCumplido => console.log(resultadoCumplido ) )
      .catch( resultadoRechazado => console.log( resultadoRechazado ) )
      .finally( () => console.log( "La Promesa se ha liquidado." ) );
    > "Error: Esta Promesa ha sido rechazada."
    > "La Promesa se ha liquidado."

A diferencia de `then` y `catch`, que permiten ejecutar una funci√≥n manejadora cuando una Promesa es cumplida o rechazada, una funci√≥n pasada como argumento al m√©todo `finally` se llama independientemente de si la Promesa fue cumplida o rechazada. La funci√≥n manejadora se llama sin argumentos, porque no est√° destinada a trabajar con los valores pasados desde la Promesa, sino solo a ejecutar c√≥digo despu√©s de que la Promesa est√© completa.

#### Concurrencia

El constructor Promise proporciona cuatro m√©todos para trabajar con m√∫ltiples Promesas relacionadas, utilizando un iterable que contiene objetos Promise. Estos m√©todos devuelven cada uno una Promesa, que se cumple o rechaza seg√∫n el estado de las Promesas que se le pasan. `Promise.all()`, por ejemplo, crea una Promesa que se cumple solo si cada Promesa pasada a ese m√©todo es cumplida:

    const primeraPromesa  = new Promise( ( cumplir, rechazar ) => cumplir( "Exitosa. ") );
    const segundaPromesa = new Promise( ( cumplir, rechazar ) => cumplir( "Exitosa. ") );
    const terceraPromesa  = new Promise( ( cumplir, rechazar ) => cumplir( "Exitosa. ") );
    const promesaFallida = new Promise( ( cumplir, rechazar ) => rechazar( "Fallida.") );
    const promesasExitosas = [ primeraPromesa, segundaPromesa, terceraPromesa ];
    const unaPromesaFallida = [ promesaFallida, ...promesasExitosas ];

    Promise.all( promesasExitosas )
      .then( ( todosLosValores ) => {
        console.log( todosLosValores );
      })
      .catch( ( valorFallido ) => {
        console.error( valorFallido );
      });
    > Array(3) [ "Exitosa. ", "Exitosa. ", "Exitosa. " ]

    Promise.all( unaPromesaFallida  )
        .then( ( todosLosValores ) => {
          console.log( todosLosValores );
        })
        .catch( ( valorFallido ) => {
            console.error( valorFallido );
        });
    > "Fallida."

Los m√©todos de concurrencia de Promise son los siguientes:

`Promise.all()`
:   Se cumple solo si todas las Promesas suministradas son cumplidas.

`Promise.any()`
:   Se cumple si cualquiera de las Promesas suministradas es cumplida, y se rechaza solo si todas las Promesas son rechazadas.

`Promise.allSettled()`
:   Se cumple cuando las Promesas se han liquidado, independientemente de su resultado.

`Promise.race()`
:   Se rechaza o cumple bas√°ndose en el resultado de la primera Promesa en liquidarse, ignorando todas las Promesas liquidadas posteriormente.

#### `async`/`await`

Cuando usas la palabra clave `async` antes de una declaraci√≥n de funci√≥n o expresi√≥n de funci√≥n, cualquier valor que esa funci√≥n retorne se devuelve como una Promesa cumplida que contiene ese valor. Esto te permite ejecutar y gestionar operaciones as√≠ncronas utilizando los mismos flujos de trabajo que el desarrollo s√≠ncrono.

    async function miFuncion() {
      return "Este es mi valor retornado.";
    }

    miFuncion().then( miValorRetornado => console.log( miValorRetornado ) );
    > "Este es mi valor retornado."

La expresi√≥n `await` pausa la ejecuci√≥n de una funci√≥n as√≠ncrona mientras se liquida la Promesa asociada. Despu√©s de que la Promesa se liquida, el valor de la expresi√≥n `await` es el valor cumplido o rechazado de la Promesa.

    async function miFuncion() {
      const miPromesa  = new Promise( ( cumplir, rechazar ) => { setTimeout( () => cumplir( "Exitosa. "), 5000 ); });
      const miResultadoPromesa = await miPromesa;
      return miResultadoPromesa;
    }

    miFuncion()
      .then( miResultado => console.log( miResultado ) )
      .catch( miResultadoFallido => console.error( miResultadoFallido ) );
    > "Exitosa."

Cualquier valor que no sea una Promesa incluido en una expresi√≥n `await` se devuelve como una Promesa cumplida:

    async function miFuncion() {
      const miResultadoPromesa = await "Valor de cadena.";
      return miResultadoPromesa;
    }

    miFuncion()
      .then( miResultado => console.log( miResultado ) )
      .catch( miResultadoFallido => console.error( miResultadoFallido ) );
    > "Valor de cadena."
</script>
</body>
</html>