<!DOCTYPE html>
<html>
<body>
<h2> 隆Expresiones de funci贸n!</h2>
<script>
//# Expresiones de funci贸n

//Las expresiones de funci贸n son funciones creadas donde se espera una expresi贸n. Con frecuencia encontrar谩s expresiones de funci贸n como valores asignados a una variable. Aunque una declaraci贸n de funci贸n siempre requiere un nombre, puedes usar expresiones de funci贸n para crear funciones an贸nimas omitiendo el identificador y siguiendo la palabra clave `function` con un par de par茅ntesis que contienen par谩metros opcionales:*/

{
    const miVariable = function() { };
}

// Luego puedes llamar a esas expresiones de funci贸n usando el identificador de la variable:

{
    const miVariable = function() {
        console.log( "Esta es mi funci贸n." );
    };

    console.log(miVariable());
    //> "Esta es mi funci贸n."
}

// Tambi茅n puedes usar expresiones de funci贸n para crear funciones con nombre usando una sintaxis similar a las declaraciones de funci贸n:

{
    const miVariable = function miFuncion() {
        console.log( "Esta es mi funci贸n." );
    };

    console.log(miVariable());
    // > "Esta es mi funci贸n."
}

//Sin embargo, a diferencia de las declaraciones de funci贸n, una expresi贸n de funci贸n con nombre solo puede ser accedida por su nombre dentro de la propia funci贸n:

{
    const miVariable = function miFuncion() {
        console.log( `Soy un/una ${ typeof miFuncion }.`);
    };

    console.log(typeof miFuncion);
    //> "undefined"

    console.log(typeof miVariable);
    //> "function"

    console.log(miVariable());
    //> "Soy un/una function."
}

//Los nombres asociados con expresiones de funci贸n son 煤tiles principalmente para depuraci贸n. Una expresi贸n de funci贸n con nombre tambi茅n puede llamarse a s铆 misma recursivamente, aunque este no es un caso de uso muy com煤n en el desarrollo moderno:

{
    const miVariable = function miFuncion() {
        console.log( "Ha transcurrido un segundo." );
        setTimeout( miFuncion, 1000);
    };

    setTimeout( miVariable, 1000 );
//> "Ha transcurrido un segundo."
//> "Ha transcurrido un segundo."
//> "Ha transcurrido un segundo."
}

//### Expresiones de funci贸n flecha

//Las expresiones de funci贸n flecha (a menudo llamadas "funciones flecha" o, raramente, "funciones lambda") se introdujeron en ES6 para proporcionar una sintaxis concisa para crear expresiones de funci贸n an贸nimas con algunos comportamientos 煤nicos.

//Puedes crear una funci贸n flecha donde sea que se espere una expresi贸n, por ejemplo, como un valor asignado a una variable. En su forma m谩s com煤n, una funci贸n flecha se compone de un par de par茅ntesis que contienen cero o m谩s par谩metros, una flecha formada por un solo signo igual y un car谩cter mayor que (`=>`), y un par de llaves que contienen el cuerpo de la funci贸n:

{
    const miFuncion = () => {};
}

//Bajo ciertas condiciones, puedes hacer la sintaxis a煤n m谩s compacta. Si solo usas un par谩metro, puedes omitir los par茅ntesis iniciales:

{
    const miFuncion = miParametro => {};
}

//Cuando quieres que el cuerpo de la funci贸n retorne el valor de una sola expresi贸n, no se requiere ni encerrar el cuerpo de la funci贸n entre llaves ni la palabra clave `return`:

{
    const miFuncion = () => 2 + 2

    console.log(miFuncion());
    //> 4
}

//Las funciones flecha son 煤nicas porque no tienen su propio contexto para los valores de `arguments`. En su lugar, heredan ambos valores del *entorno l茅xicamente contenedor* de la funci贸n flecha, es decir, la funci贸n contenedora m谩s cercana que s铆 proporciona esos contextos.

{
    function miFuncionPadre() {
        this.miPropiedad = true;
        let miFuncion = () => {
                console.log( this );
        }
        miFuncion();
    };

    let miInstancia = new miFuncionPadre();
//> Object { miPropiedad: true }
}

//### Llamar a funciones flecha

//Las funciones flecha no vinculan los argumentos de la misma manera que otros tipos de funciones. Un objeto `arguments` en el cuerpo de una funci贸n flecha hereda su valor del entorno l茅xicamente contenedor m谩s cercano de esa funci贸n flecha:

{
    function miFuncion() {
        let miFuncionFlecha = () => {
                console.log( arguments[ 0 ] );
        }
        miFuncionFlecha( true );
    };

    miFuncion( false );
    //> false
}

//En este ejemplo, una funci贸n externa llamada con el argumento `false` llama a una funci贸n flecha interna con el argumento `true`. Debido a que el objeto `arguments` dentro de la funci贸n flecha se resuelve a la vinculaci贸n en la funci贸n externa, la funci贸n interna registra el `false` de la funci贸n externa.

//Si no hay ning煤n objeto `arguments` que heredar del contexto padre, el objeto `arguments` de la funci贸n flecha no est谩 definido, e intentar acceder a 茅l causa un error:

{
    let miFuncionFlecha = () => {
        console.log(arguments);
    };
    //miFuncionFlecha( true );
    //> Uncaught ReferenceError: arguments is not defined
}

//### Expresiones de funci贸n invocadas inmediatamente (IIFE)

//Una Expresi贸n de Funci贸n Invocada Inmediatamente (IIFE, por sus siglas en ingl茅s), tambi茅n llamada a veces "funci贸n an贸nima autoejecutable", es una expresi贸n de funci贸n que se llama inmediatamente cuando es definida. Una IIFE utiliza una expresi贸n de funci贸n creada al encerrar la funci贸n en un operador de agrupaci贸n. Un segundo par de par茅ntesis llama a la funci贸n, ya sea inmediatamente despu茅s de la definici贸n de la funci贸n o inmediatamente despu茅s del operador de agrupaci贸n. Si usas una funci贸n est谩ndar, no hay diferencia pr谩ctica entre los dos enfoques:

{
    (function() {
        console.log( "IIFE.")
        }
    )();
    //> "IIFE."
}
{
    (function() {
        console.log( "IIFE.")
        }
    ());
    //> "IIFE."
}

//El primer ejemplo llama a la expresi贸n de funci贸n agrupada. El segundo ejemplo llama a una declaraci贸n de funci贸n dentro de los operadores de agrupaci贸n, y el resultado final se eval煤a entonces como una expresi贸n agrupada. El resultado es el mismo en ambos casos.

//Sin embargo, hay una diferencia cuando tu IIFE es una funci贸n flecha. En este caso, los par茅ntesis utilizados para llamar a la funci贸n deben estar fuera de los operadores de agrupaci贸n, porque una funci贸n flecha por s铆 sola no es una expresi贸n, pero debe ser creada en un contexto donde se espera una expresi贸n. Intentar llamar a la funci贸n flecha desde dentro del 谩mbito de los operadores de agrupaci贸n significar铆a llamar a una funci贸n flecha que a煤n no ha sido creada en el contexto de una expresi贸n:

/*( () => {
        console.log( "IIFE." );
    }() );*/
    //> Uncaught SyntaxError: missing ) in parenthetical

//Debido a que los operadores de agrupaci贸n esperan una expresi贸n, la funci贸n flecha dentro de ellos est谩 definida, lo que permite que los par茅ntesis que los siguen llamen a la expresi贸n agrupada:

{
    ( () => {
        console.log( "IIFE." );
    } )();
    //> "IIFE."
}
//Aplicaciones heredadas, IIFE utilizado con frecuencia para administrar el alcance, espec铆ficamente para evitar contaminar el alcance global con variables con alcance de funci贸n y declaraciones de funciones. Antes de la introducci贸n del alcance de bloque en ES6, era com煤n unir una secuencia de comandos completa en un IIFE para evitar la contaminaci贸n accidental del alcance global.
</script>
</body>
</html>