<!DOCTYPE html>
<html>
<body>
<h2>ðŸ˜™ Â¡La palabra clave nueva!</h2>
<script>
La palabra clave nueva

Si llamas a una funciÃ³n con new, se crea un objeto nuevo con la funciÃ³n llamada como el "constructor" para ese objeto:


function MyFunction() {}
const myObject = new MyFunction();

typeof myObject;
> "object"`
Esto permite que una "funciÃ³n de constructor" proporcione una plantilla para la creaciÃ³n de objetos que siguen el mismo patrÃ³n estructural:


function MyFunction() {
  this.myProperty = true;
}
const myObject = new MyFunction();

myObject.myProperty;
> true
El valor de this dentro de un constructor â€œfunciÃ³nâ€ se refiere al objeto que se crea, lo que permite que este se propague con propiedades y mÃ©todos al momento de la creaciÃ³n. Esto permite que los la creaciÃ³n de objetos que contienen valores de datos y cualquier mÃ©todo necesario para actuar sobre ellos esos datos como una sola unidad portÃ¡til, un concepto llamado â€œencapsulamientoâ€:


function MyFunction( myArgument ) {
    this.myValue = myArgument;
    this.doubleMyValue = () => myArgument * 2;
}
const myObject = new MyFunction( 10 );

myObject.myValue;
> 10

myObject.doubleMyValue();
> 20
this hace referencia al contexto de ejecuciÃ³n actual de una funciÃ³n, lo que significa que una funciÃ³n de constructor sigue las mismas reglas para el valor de this que cualquier otra funciÃ³n. Por ejemplo, una funciÃ³n previsto como constructor, usa vinculaciÃ³n global para el valor de this cuando se invoca de forma independiente:


function MyFunction() {
    console.log( this  );
}
const myObject = new MyFunction();
> MyFunction { }

MyFunction(); // Global `this` binding outside of strict mode is `globalThis`
> Window { â€¦ }

(function() {
    "use strict";
    function MyFunction() {
            console.log( this );
    }
    MyFunction();  // Global `this` binding inside of strict mode is `undefined`
}());
> undefined
Es convencional usar mayÃºsculas en el primer carÃ¡cter del nombre de la funciÃ³n de constructor. de asignaciÃ³n de nombres, siguiendo el patrÃ³n de nomenclatura establecido por funciones de fÃ¡brica. Aunque a veces veas que los tÃ©rminos se usan de forma indistinta, de constructores: funciones destinadas a actuar en un edificio recientemente construido, cuando se invoca con la palabra clave new, difiere de â€œFactory funciones," que explÃ­citamente return un cuando se invoca normalmente:


function myFunction( myArgument = false ) {
  return { "myProperty" : myArgument };
}
const myObject = myFunction( true );

myObject;
> Object { myProperty: true }
Aunque los principios subyacentes son los mismos, los casos de uso de los modelos Las funciones de constructor se entregan mejor con la mÃ¡s completa La sintaxis de Class incluida en ES6
</script>
</body>
</html>